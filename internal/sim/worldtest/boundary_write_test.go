package worldtest

import (
	"testing"

	"voxelcraft.ai/internal/protocol"
	"voxelcraft.ai/internal/sim/catalogs"
	world "voxelcraft.ai/internal/sim/world"
)

func TestBoundaryWriteConsistency_PlaceOutsideFailsAndNoInventoryLoss(t *testing.T) {
	cats, err := catalogs.Load("../../../configs")
	if err != nil {
		t.Fatalf("load catalogs: %v", err)
	}
	h := NewHarness(t, world.WorldConfig{
		ID:           "test",
		Seed:         3,
		BoundaryR:    8,
		StarterItems: map[string]int{"CRAFTING_BENCH": 1},
	}, cats, "builder")
	h.StepNoop() // tick 1

	if ok := h.W.DebugSetAgentPos(h.DefaultAgentID, world.Vec3i{X: 0, Y: 0, Z: 0}); !ok {
		t.Fatalf("DebugSetAgentPos returned false")
	}

	outPos := [3]int{9, 0, 0}
	h.Step(nil, []protocol.TaskReq{{ID: "K1", Type: "PLACE", ItemID: "CRAFTING_BENCH", BlockPos: outPos}}, nil)
	obs := h.LastObs()

	if got := invCount(obs.Inventory, "CRAFTING_BENCH"); got != 1 {
		t.Fatalf("inventory changed on out-of-bounds place: got %d want 1", got)
	}

	taskID := ""
	for _, e := range obs.Events {
		if e["type"] != "ACTION_RESULT" || e["ref"] != "K1" {
			continue
		}
		if ok, _ := e["ok"].(bool); !ok {
			t.Fatalf("expected ACTION_RESULT ok=true, got ok=%v code=%v", e["ok"], e["code"])
		}
		if s, _ := e["task_id"].(string); s != "" {
			taskID = s
		}
		break
	}
	if taskID == "" {
		t.Fatalf("missing task_id from ACTION_RESULT; events=%v", obs.Events)
	}

	foundFail := false
	for _, e := range obs.Events {
		if e["type"] != "TASK_FAIL" || e["task_id"] != taskID {
			continue
		}
		foundFail = true
		if code, _ := e["code"].(string); code != "E_INVALID_TARGET" {
			t.Fatalf("expected E_INVALID_TARGET, got %v", e["code"])
		}
		break
	}
	if !foundFail {
		t.Fatalf("expected TASK_FAIL for out-of-bounds place; events=%v", obs.Events)
	}
}

func TestBoundaryWriteConsistency_SetBlockOutsideDoesNotGenerateChunk(t *testing.T) {
	s := world.NewChunkStore(world.WorldGen{Air: 0, BoundaryR: 8})
	if got := len(s.LoadedChunkKeys()); got != 0 {
		t.Fatalf("unexpected initial chunk keys: %d", got)
	}

	// y!=0 is invalid in 2D and should not generate any chunk.
	s.SetBlock(world.Vec3i{X: 1000, Y: 10, Z: 0}, 1)
	if got := len(s.LoadedChunkKeys()); got != 0 {
		t.Fatalf("expected no chunks to be generated by out-of-bounds SetBlock, got %d", got)
	}
}
