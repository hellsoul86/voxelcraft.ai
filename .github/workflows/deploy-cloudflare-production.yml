name: Deploy Cloudflare Production

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - 'cmd/**'
      - 'internal/**'
      - 'configs/**'
      - 'cloudflare/**'
      - 'Dockerfile.cloudflare'
      - '.github/workflows/deploy-cloudflare-production.yml'
      - 'go.mod'
      - 'go.sum'
      - 'scripts/release_gate.sh'

permissions:
  contents: read

concurrency:
  group: deploy-cloudflare-production-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-production:
    name: Deploy production (Containers + DO + D1 + R2)
    runs-on: ubuntu-latest
    timeout-minutes: 90
    environment:
      name: production
      url: https://api.voxelcraft.ai
    env:
      CLOUDFLARE_ACCOUNT_ID: ${{ vars.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_D1_DATABASE_ID: ${{ vars.CLOUDFLARE_D1_DATABASE_ID }}
      CLOUDFLARE_R2_BUCKET: ${{ vars.CLOUDFLARE_R2_BUCKET }}
      VC_R2_ACCESS_KEY_ID: ${{ secrets.VC_R2_ACCESS_KEY_ID }}
      VC_R2_SECRET_ACCESS_KEY: ${{ secrets.VC_R2_SECRET_ACCESS_KEY }}
      VC_MCP_HMAC_SECRET: ${{ secrets.VC_MCP_HMAC_SECRET }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required Cloudflare config (secrets + vars)
        run: |
          required=(
            CLOUDFLARE_ACCOUNT_ID
            CLOUDFLARE_API_TOKEN
            CLOUDFLARE_D1_DATABASE_ID
            CLOUDFLARE_R2_BUCKET
            VC_R2_ACCESS_KEY_ID
            VC_R2_SECRET_ACCESS_KEY
            VC_MCP_HMAC_SECRET
          )
          missing=0
          for key in "${required[@]}"; do
            if [ -z "${!key}" ]; then
              echo "::error title=Missing config::$key is required"
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            echo "Set missing repo/env secrets or variables before re-running."
            exit 1
          fi

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Run Full Release Gate (with race)
        run: scripts/release_gate.sh

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: npm
          cache-dependency-path: cloudflare/package-lock.json

      - name: Install Cloudflare deploy dependencies
        working-directory: cloudflare
        run: npm ci

      - name: Render production wrangler config
        working-directory: cloudflare
        run: |
          cp wrangler.toml wrangler.generated.toml
          sed -i "s|__D1_DATABASE_ID__|${CLOUDFLARE_D1_DATABASE_ID}|g" wrangler.generated.toml
          sed -i "s|__R2_BUCKET_NAME__|${CLOUDFLARE_R2_BUCKET}|g" wrangler.generated.toml
          sed -i "s|__CF_ACCOUNT_ID__|${CLOUDFLARE_ACCOUNT_ID}|g" wrangler.generated.toml

      - name: Upsert container credentials (Worker secrets)
        working-directory: cloudflare
        run: |
          printf '%s' "$VC_R2_ACCESS_KEY_ID" | npx wrangler secret put VC_R2_ACCESS_KEY_ID --env production --config wrangler.generated.toml
          printf '%s' "$VC_R2_SECRET_ACCESS_KEY" | npx wrangler secret put VC_R2_SECRET_ACCESS_KEY --env production --config wrangler.generated.toml

          # Reuse existing repo secret (no extra GitHub secret required):
          # derive a dedicated ingest token from CLOUDFLARE_API_TOKEN, so the raw API token
          # is not exposed to container runtime.
          VC_INDEX_D1_TOKEN_DERIVED="$(printf '%s' "$CLOUDFLARE_API_TOKEN" | sha256sum | awk '{print $1}')"
          printf '%s' "$VC_INDEX_D1_TOKEN_DERIVED" | npx wrangler secret put VC_INDEX_D1_TOKEN --env production --config wrangler.generated.toml

          # MCP HMAC secret (required in staging/production).
          printf '%s' "$VC_MCP_HMAC_SECRET" | npx wrangler secret put VC_MCP_HMAC_SECRET --env production --config wrangler.generated.toml

      - name: Apply D1 schema (idempotent)
        working-directory: cloudflare
        run: npx wrangler d1 execute VOXEL_D1 --remote --env production --config wrangler.generated.toml --file ./d1/schema.sql

      - name: Deploy Worker + Container image (retry transient domains API failures)
        working-directory: cloudflare
        run: |
          max_attempts=3
          attempt=1
          while true; do
            echo "Deploy attempt ${attempt}/${max_attempts}"
            set +e
            output="$(npx wrangler deploy --env production --config wrangler.generated.toml 2>&1)"
            status=$?
            set -e

            printf '%s\n' "$output"

            if [ "$status" -eq 0 ]; then
              break
            fi

            if printf '%s\n' "$output" | grep -qE 'domains/records -> 502 Bad Gateway|Received a malformed response from the API'; then
              if [ "$attempt" -lt "$max_attempts" ]; then
                sleep_sec=$((attempt * 20))
                echo "Transient Cloudflare domain API failure detected; retrying in ${sleep_sec}s..."
                sleep "$sleep_sec"
                attempt=$((attempt + 1))
                continue
              fi
            fi

            echo "::error title=Wrangler deploy failed::Non-retryable error or max retries reached."
            exit "$status"
          done

      - name: Post-deploy quick checks
        env:
          BASE_URL: https://api.voxelcraft.ai
        run: |
          set -euo pipefail

          BASE_URL="${BASE_URL%/}"
          echo "Running post-deploy quick checks against: ${BASE_URL}"

          retry() {
            local max_attempts="$1"; shift
            local sleep_seconds="$1"; shift
            local attempt=1

            while true; do
              if "$@"; then
                return 0
              fi

              if [ "$attempt" -ge "$max_attempts" ]; then
                echo "::error title=Quick check failed::Command failed after ${attempt}/${max_attempts} attempts: $*"
                return 1
              fi

              echo "Retry ${attempt}/${max_attempts} failed; sleeping ${sleep_seconds}s..."
              sleep "$sleep_seconds"
              attempt=$((attempt + 1))
              sleep_seconds=$((sleep_seconds * 2))
              if [ "$sleep_seconds" -gt 30 ]; then
                sleep_seconds=30
              fi
            done
          }

          get_to_file() {
            local url="$1"
            local out="$2"
            curl -fsS --max-time 20 "$url" -o "$out"
          }

          post_mcp_signed_to_file() {
            local body="$1"
            local out="$2"
            local agent_id="gha-smoke"

            read -r ts nonce sig < <(python3 - <<PY
          import hmac, hashlib, os, secrets, time

          secret = os.environ.get('VC_MCP_HMAC_SECRET', '').encode('utf-8')
          if not secret:
              raise SystemExit('VC_MCP_HMAC_SECRET is required for MCP check')

          body = '''${body}'''
          agent_id = '${agent_id}'
          ts = str(int(time.time() * 1000))
          nonce = secrets.token_hex(16)
          canonical = f"{ts}\nPOST\n/mcp\n{agent_id}\n{nonce}\n{body}"
          sig = hmac.new(secret, canonical.encode('utf-8'), hashlib.sha256).hexdigest()

          print(ts, nonce, sig)
          PY
          )

            curl -fsS --max-time 30 -X POST "${BASE_URL}/mcp" \
              -H "content-type: application/json" \
              -H "x-agent-id: ${agent_id}" \
              -H "x-ts: ${ts}" \
              -H "x-nonce: ${nonce}" \
              -H "x-signature: ${sig}" \
              --data "$body" \
              -o "$out"
          }

          echo "[check] GET /healthz"
          retry 12 2 get_to_file "${BASE_URL}/healthz" /tmp/healthz.txt
          grep -qi "ok" /tmp/healthz.txt

          echo "[check] GET /_cf/persistence/healthz"
          retry 12 2 get_to_file "${BASE_URL}/_cf/persistence/healthz" /tmp/persistence.json
          python3 - <<'PY'
          import json

          with open('/tmp/persistence.json', 'r', encoding='utf-8') as f:
              obj = json.load(f)

          assert obj.get('ok') is True, obj
          storage = obj.get('storage') or {}
          assert storage.get('d1') == 'ok', obj
          assert storage.get('r2') == 'ok', obj
          print('persistence ok:', storage)
          PY

          echo "[check] GET /_cf/indexdb/healthz?world_id=OVERWORLD"
          retry 12 2 get_to_file "${BASE_URL}/_cf/indexdb/healthz?world_id=OVERWORLD" /tmp/indexdb.json
          python3 - <<'PY'
          import json

          with open('/tmp/indexdb.json', 'r', encoding='utf-8') as f:
              obj = json.load(f)

          assert obj.get('ok') is True, obj
          print('indexdb ok:', {k: obj.get(k) for k in ('world_id', 'index') if k in obj})
          PY

          echo "[check] POST /mcp initialize (client-signed; required in production)"
          retry 12 2 post_mcp_signed_to_file '{"jsonrpc":"2.0","id":1,"method":"initialize"}' /tmp/mcp_init.json
          python3 - <<'PY'
          import json

          with open('/tmp/mcp_init.json', 'r', encoding='utf-8') as f:
              obj = json.load(f)

          assert obj.get('error') is None, obj
          result = obj.get('result') or {}
          assert result.get('protocolVersion'), obj
          print('mcp initialize ok: protocolVersion=', result.get('protocolVersion'))
          PY

          echo "[check] POST /mcp call_tool voxelcraft.get_obs (wait_new_tick=true)"
          retry 12 2 post_mcp_signed_to_file '{"jsonrpc":"2.0","id":2,"method":"call_tool","params":{"name":"voxelcraft.get_obs","arguments":{"mode":"summary","wait_new_tick":true,"timeout_ms":5000}}}' /tmp/mcp_obs.json
          python3 - <<'PY'
          import json

          with open('/tmp/mcp_obs.json', 'r', encoding='utf-8') as f:
              obj = json.load(f)

          assert obj.get('error') is None, obj
          result = obj.get('result') or {}
          tick = result.get('tick')
          assert isinstance(tick, int) and tick > 0, obj
          print('mcp get_obs ok: tick=', tick)
          PY

          echo "All post-deploy quick checks passed."
