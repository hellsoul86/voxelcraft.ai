name: Deploy Cloudflare Staging

on:
  workflow_dispatch:
  push:
    branches:
      - staging
    paths:
      - 'cmd/**'
      - 'internal/**'
      - 'configs/**'
      - 'cloudflare/**'
      - 'Dockerfile.cloudflare'
      - '.github/workflows/deploy-cloudflare-staging.yml'
      - 'go.mod'
      - 'go.sum'
      - 'scripts/release_gate.sh'

permissions:
  contents: read

concurrency:
  group: deploy-cloudflare-staging-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-staging:
    name: Deploy staging (Containers + DO + D1 + R2)
    runs-on: ubuntu-latest
    timeout-minutes: 90
    environment:
      name: staging
      url: https://staging-api.voxelcraft.ai
    env:
      CLOUDFLARE_ACCOUNT_ID: ${{ vars.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_D1_DATABASE_ID: ${{ vars.CLOUDFLARE_D1_DATABASE_ID }}
      CLOUDFLARE_R2_BUCKET: ${{ vars.CLOUDFLARE_R2_BUCKET }}
      VC_R2_ACCESS_KEY_ID: ${{ secrets.VC_R2_ACCESS_KEY_ID }}
      VC_R2_SECRET_ACCESS_KEY: ${{ secrets.VC_R2_SECRET_ACCESS_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required Cloudflare config (secrets + vars)
        run: |
          required=(
            CLOUDFLARE_ACCOUNT_ID
            CLOUDFLARE_API_TOKEN
            CLOUDFLARE_D1_DATABASE_ID
            CLOUDFLARE_R2_BUCKET
            VC_R2_ACCESS_KEY_ID
            VC_R2_SECRET_ACCESS_KEY
          )
          missing=0
          for key in "${required[@]}"; do
            if [ -z "${!key}" ]; then
              echo "::error title=Missing config::$key is required"
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            echo "Set missing repo/env secrets or variables before re-running."
            exit 1
          fi

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Run Full Release Gate (with race)
        run: scripts/release_gate.sh

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: npm
          cache-dependency-path: cloudflare/package-lock.json

      - name: Install Cloudflare deploy dependencies
        working-directory: cloudflare
        run: npm ci

      - name: Render staging wrangler config
        working-directory: cloudflare
        run: |
          cp wrangler.toml wrangler.generated.toml
          sed -i "s|__D1_DATABASE_ID__|${CLOUDFLARE_D1_DATABASE_ID}|g" wrangler.generated.toml
          sed -i "s|__R2_BUCKET_NAME__|${CLOUDFLARE_R2_BUCKET}|g" wrangler.generated.toml
          sed -i "s|__CF_ACCOUNT_ID__|${CLOUDFLARE_ACCOUNT_ID}|g" wrangler.generated.toml

      - name: Upsert container credentials (Worker secrets)
        working-directory: cloudflare
        run: |
          printf '%s' "$VC_R2_ACCESS_KEY_ID" | npx wrangler secret put VC_R2_ACCESS_KEY_ID --env staging --config wrangler.generated.toml
          printf '%s' "$VC_R2_SECRET_ACCESS_KEY" | npx wrangler secret put VC_R2_SECRET_ACCESS_KEY --env staging --config wrangler.generated.toml

          # Reuse existing repo secret (no extra GitHub secret required):
          # derive a dedicated ingest token from CLOUDFLARE_API_TOKEN, so the raw API token
          # is not exposed to container runtime.
          VC_INDEX_D1_TOKEN_DERIVED="$(printf '%s' "$CLOUDFLARE_API_TOKEN" | sha256sum | awk '{print $1}')"
          printf '%s' "$VC_INDEX_D1_TOKEN_DERIVED" | npx wrangler secret put VC_INDEX_D1_TOKEN --env staging --config wrangler.generated.toml

          # MCP HMAC secret (reusing CLOUDFLARE_API_TOKEN; avoids introducing a new GitHub secret).
          # Agent-side should use the same derivation: sha256("vc_mcp:staging:" + CLOUDFLARE_API_TOKEN)
          VC_MCP_HMAC_SECRET_DERIVED="$(printf '%s' "vc_mcp:staging:$CLOUDFLARE_API_TOKEN" | sha256sum | awk '{print $1}')"
          printf '%s' "$VC_MCP_HMAC_SECRET_DERIVED" | npx wrangler secret put VC_MCP_HMAC_SECRET --env staging --config wrangler.generated.toml

      - name: Apply D1 schema (idempotent)
        working-directory: cloudflare
        run: npx wrangler d1 execute VOXEL_D1 --remote --env staging --config wrangler.generated.toml --file ./d1/schema.sql

      - name: Deploy Worker + Container image (retry transient domains API failures)
        working-directory: cloudflare
        run: |
          max_attempts=3
          attempt=1
          while true; do
            echo "Deploy attempt ${attempt}/${max_attempts}"
            set +e
            output="$(npx wrangler deploy --env staging --config wrangler.generated.toml 2>&1)"
            status=$?
            set -e

            printf '%s\n' "$output"

            if [ "$status" -eq 0 ]; then
              break
            fi

            if printf '%s\n' "$output" | grep -qE 'domains/records -> 502 Bad Gateway|Received a malformed response from the API'; then
              if [ "$attempt" -lt "$max_attempts" ]; then
                sleep_sec=$((attempt * 20))
                echo "Transient Cloudflare domain API failure detected; retrying in ${sleep_sec}s..."
                sleep "$sleep_sec"
                attempt=$((attempt + 1))
                continue
              fi
            fi

            echo "::error title=Wrangler deploy failed::Non-retryable error or max retries reached."
            exit "$status"
          done

      - name: Post-deploy quick checks
        run: |
          echo "Deployment finished."
          echo "Check /healthz, /_cf/persistence/healthz, and /_cf/indexdb/healthz on the staging URL."
